![Alt text](0_img/pylogo.png?raw=true "Title")
# Content table # 
- [Уроки](#Уроки)
    - [урок 3](#урок3)
    - [урок 4 Переменные](#4.Переменные)
    - [урок5 Условные операторы](#5.Условные\sоператоры)
    - [урок6  Циклы For, While, а также операторы](#6.Циклы For, While, а также операторы)
    - [урок7](#урок7)
    - [урок8](#урок8)
    - [урок9](#урок9)
    - [урок10](#урок10)
    - [урок 11 Множества](#11Множества)

## Уроки ##
### урок3 ###
![Alt text](0_img/errors.png?raw=true "Title")
### 4.Переменные ###
В ходе самой программы мы можем перезаписывать значение переменной, при этом мы можем указывать новый тип переменной. К примеру, изначально был записан тип float, но потом можно записать другой тип данных:
```python
first_num = 23.2 # Тип данных float
first_num = "1" # Тип данных String
```
Тем не менее, если мы попытаемся сложить две переменные с разными типами данных, то это вызовет ошибку.

```python
first_num = "Some"
second_num = 21
res = first_num + second_num # Здесь будет ошибка
```
Ниже приводим все существующие типы данных в языке Python:

```python
some = 1 Integer - целые числа
some = 1.12 Float - числа с плавающей точкой
some = "Привет" String - строки
```

Есть и другие типы, но их мы будем разбирать в последующих уроках.

Также можно присваивать сразу несколько переменных:
```python
first = sec = third = 1 # Всем трем переменным будет присвоено значение 1
first, sec, third = "Hi", 75, 23.1 # Поочередное присвоение значений
```
### 5.Условные\sоператоры ###
Условные операторы помогают проверить несколько значений и выполнить код в зависимости от итога проверки. Вы можете создавать вложенные условные операторы, которые будут дополнительно проверять данные. Также можно проверять несколько условий в одном операторе. К примеру, чтобы проверить сразу два условия в одном операторе потребуется использовать операцию and (логическое и):
```python
a = 2
if a != 0 and a != 1:
   print ("Проверка сработала")
```
Эта проверка сработает лишь в том случае, если оба условия окажутся как истинными (true).

Также можно проверять при помощи логического или or. В этом случае если хотя бы одно условие является верным (true), то код внутри условия будет выполнен:
```python 
a = 1.1
if a != 1.1 or a > 0:
   print ("Проверка сработала")
```
Операции на условие:
```python
num = input ("Введите число: ")

if int (num) > 0:
	if int (num) > 10:
		print ("Вы ввели число больше 10")
		if int (num) >= 50:
			print ("Вы ввели число больше 50")
	else:
		print ("Вы ввели число меньше 10 и больше 0")
elif int (num) < -10:
	print ("Вы ввели число меньше -10")
else:
	print ("Вы ввели число меньше 0 и больше -10")
print ("All is okay!")

name = input ()
A = 'Yes' if name != "Test" else 'No'
print (A)
```
### урок6 ###
####  Циклы For, While, а также операторы ####
Циклы позволяют выполнять некий код несколько раз подряд. Это особенно полезно при работе с массивами. В языке Python циклы немного отличаются по своему виду от циклов в других языках. К примеру, во многих языках есть цикл do..while, который выполняется один раз сто процентов, а потом проверяет условие. В питоне его нет- но можно заменить.

Также важно отметить, что вы можете создать бесконечный цикл, но с оператором break, который выйдет из цикла:
```python
a = 10
while True:
  a -= 1
  if a == 0:
    break
```

Такой цикл сработает корректно, так как у нас есть оператор break, который сработает в нужный момент и выйдет из цикла.
Пример кода с циклами
```python
i = 1000
while i > 100:
	print (i)
	i /= 2

for j in 'hello world':
	if j == 'w':
		break
else:
	print ("Буквы а нету в слове")
```
### урок7 ###
#### Списки (list) ####
Списки можно также назвать массивами, так как выполняют они схожую роль. В Python существует множество разновидностей таких "массивов". В уроке мы рассмотрели лишь первый тип, который называется списком и имеет следующие характеристики:
его элементы можно переопределять;
в него можно добавлять новые элементы;
из него можно удалять элементы;
в качестве ключей идут индексы (числа - 0, 1, 2...).
Это не все характеристики списка, тем не менее это ключевые моменты, которые отличают его от других "массивов" в языке Python.

Для списков существует большое количество функций, которые можно применять для добавления, удаления или же поиска элементов.

Пример создания списка:

```python
lis = ["Андрей", "Иван", "Василий", "Петро", "Максим", "Дима"]
```
```python
l = []
lis = [1, 56, 'x', 34, 2.34, ['S', 't', 'r', 'o', 'k', 'a']]
print (lis)

a = [a + b for a in 'list' if a != 's' for b in 'soup' if b != 'u']
print (a)

l.append (23)
l.append (34)
b = [24, 67]
l.extend (b) # все элемены b расширяют l
#i>>> print (l)
#[23, 34, 24, 67]
l.insert (1, 56)
l.append (34)
l.remove (34)
l.pop (0)
print (l.index (56))
print (l.count (34))
l.sort ()
l.reverse ()
l.clear ()

print (l)
```

### урок8 ###
#### Индексы и срезы ####
Нумерация в списках начинается с нуля, так как список по большей части своей это просто массив, то как в обычном массиве отсчет ведется от 0. Поэтому первый элемент по индексу будет 0, второй - 1, третий - 2 и так далее. Если мы попытаемся взять несуществующий элемент, то это приведет к ошибке.
```python
a = [0, 23, "Hi"] # Список
print (a[4]) # Выдаст ошибку, так как элемента не существует
```
Очень удобной функцией языка Python является возможность брать элементы с конца при помощи отрицательных индексов. К примеру, если нам нужен второй элемнет с конца, то мы можем записать это так:
```python
a = [0, 23, "Hi", 1.56, 9] # Список
print (a[-2]) # Будет выведено 1.56
```
Срезы
Срезы позволяют обрезать список, взяв лишь те элементы, которые нам будут нужны. Они работают по следующей схеме: list[НАЧАЛО:КОНЕЦ:ШАГ].
Начало - с какого элемента стоит начать (по умолчанию равна 0);
Конец - по какой элемент мы берем элементы (по умолчанию равно длине списка);
Шаг - с каким шагом берем элементы, к примеру каждый 2 или 3 (по умолчанию каждый 1).
Один, несколько или даже все параметры могут быть пропущены.
```python
list[::3] # Берем каждый третий элемент
list[2::2] # Начиная со второго элемента берем каждый второй элемент
list[4:6:] # Начиная с 4 элемента берем все элементы по 6 элемент
list[::] # Берем все элементы
```
Также могут быть использованы отрицательные числа для срезов.
```python
l = [34, 'sd', 56, 34.34]

i = 0
while i < 4:
	print (l[i])
	i += 1
	
print (l[-2::-2])
```

### урок9 ###
#### Кортежи (tuple) ####
Кортежи это по сути те же самые списки, только с несколькими отличиями. Кортежи нельзя изменять после их создания, а также они весят чуть меньше, чем списки.

При работе с кортежами действуют абсолютно все методы, о которых было рассказано в уроке про списки. Единственные методы, которые не будут работать, так это методы изменяющие кортеж: удаление, добавление элементов, сложение кортежей и тому подобные.

Кортежи можно создать двумя способами:
при помощи ключевого слова a = tuple ('hello');#разбиваем слово на список
при помощи литерала a = ('a','b').
Их главное преимущество в том, что их нельзя изменять, поэтому ни вы, ни кто-либо другой не сможет как случайно, так и намерено изменить кортеж.

### урок10 ###
#### Словари (dict), а также их методы ####
Словари отличаются способом записи их, а также индексами. Если в обычном списке в качестве индексов выступают числа (0, 1, 2...), то здесь на их замену приходят "ключи". Так, мы можем создать некий ключ (Студент Федя, например) и добавить к нему целый ряд характеристик (список) в качестве одного элемента. Теперь найти нужного нам студента будет намного проще, так как мы просто будет оперировать ключами, а не числами.

Во многих других языках программирования такие словари зачастую называются ассоциативными массивами, поэтому не редко можно услышать и такое название.

Чтобы создать словарь вы можете воспользоваться следующей конструкцией:
```python
d0= {'test' : 1, 'prod': 2}
d1= dict (short = 'dict', longer = 'dictionary')
d2= dict ([(23,34),(56,87)])
d3= dict.fromkeys(['a','b'], 3)
```
Методы словарей:
```python
dict.clear() # очистка словаря
dict.copy() # возвращает копию словаря
dict.fromkeys(seq[,value]) # создает словарь с ключами из seq и значениям value
dict.get(key[,default]) # возвращает значение ключа, если ключа нет - возвращаем default
dict.items() # возвращает пары ключ - значени
dict.keys() # вернуть ключи
dict.pop(key,[,default]) # удаляет ключ и возвращает значение. Если ключа нет, возвращает default (вместо исключения по умолчанию)
dict.popitem() # удаляет и возвращает пару (ключ - значение)
dict.setdefault(key[,default])  - возвращает значение ключаб если его нет - создает ключ с default
dict.update([other]) # обновляет словарь, добавляя пары из other. Существующие ключи перезаписываются. Возвращает None.
dict.values() #  возвращает значения в словаре
```

Применение словарей в Python:
```python
d = {a : a ** 2 for a in range(7)}
print (d)

person = {'name' : {'last_name': 'Иванов', 'first_name': 'Иван', 'middle_name': 'Иванович'}, 'address': ['г. Андрюшки', 'ул. Васильковская д. 23б', 'кв.12'], 'phone': {'home_phone': '34-67-12', 'mobile_phone': '8-564-345-23-65', 'mobile_phone_2': 'Нет'}}
# print (person['phone']['mobile_phone'])

print (person.keys ())
```
### 11Множества ### ### Множества (set), а также их методы ####
Множества также схожи с массивами, но есть несколько отличий. Во-первых, множества создаются в абсолютно случайном порядке каждый раз. Вы можете разместить элементы как вам будет угодно, но они все равно будут расположены впоследствии в случайном порядке. Во-вторых, множества не могут иметь повторяющихся элементов, поэтому все элементы, которые будут одинаковыми не будут выведены повторно.

Их очень удобно использовать, если вы хотите удалить повторяющиеся элементы из списка, например:
some_list = [12, 56, 91, 12]
set(some_list) # Результат: 12, 56, 91
Также для существует огромное множество операций, которые приведены ниже:
```
len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
```

С множествами можно выполнять множество операций: находить объединение, пересечение...
