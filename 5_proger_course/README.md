![Alt text](0_img/pylogo.png?raw=true "Title")
# ссылка на курс: #
https://itproger.com/course/python/1
# Content table # 
- [Уроки](#Уроки)
    - [3.Диагностика ошибок](#3-типы-ошибок)
    - [4 Переменные test](#4-переменные)
    - [5 Условные операторы](#5-условные-операторы)
    - [6 Циклы For, While, а также операторы](#6-циклы-и-операторы)
    - [7 Списки](#7-списки)
    - [8 Индексы срезы](#8-индексы-срезы)
    - [9 Кортежи](#9-кортежи-tuple)
    - [10 Словари](#10-словари-dict)
    - [11 Множества](#11-множества-set)
    - [12 Функции](#12-функции)

## Уроки ##
### урок3 ###
![Alt text](0_img/errors.png?raw=true "Title")

### 4 Переменные ###

В ходе самой программы мы можем перезаписывать значение переменной, при этом мы можем указывать новый тип переменной. К примеру, изначально был записан тип float, но потом можно записать другой тип данных:
```python
first_num = 23.2 # Тип данных float
first_num = "1" # Тип данных String
```
Тем не менее, если мы попытаемся сложить две переменные с разными типами данных, то это вызовет ошибку.

```python
first_num = "Some"
second_num = 21
res = first_num + second_num # Здесь будет ошибка
```
Ниже приводим все существующие типы данных в языке Python:

```python
some = 1 Integer - целые числа
some = 1.12 Float - числа с плавающей точкой
some = "Привет" String - строки
```

Есть и другие типы, но их мы будем разбирать в последующих уроках.

Также можно присваивать сразу несколько переменных:
```python
first = sec = third = 1 # Всем трем переменным будет присвоено значение 1
first, sec, third = "Hi", 75, 23.1 # Поочередное присвоение значений
```
### 5 Условные операторы ###
Условные операторы помогают проверить несколько значений и выполнить код в зависимости от итога проверки. Вы можете создавать вложенные условные операторы, которые будут дополнительно проверять данные. Также можно проверять несколько условий в одном операторе. К примеру, чтобы проверить сразу два условия в одном операторе потребуется использовать операцию and (логическое и):
```python
a = 2
if a != 0 and a != 1:
   print ("Проверка сработала")
```
Эта проверка сработает лишь в том случае, если оба условия окажутся как истинными (true).

Также можно проверять при помощи логического или or. В этом случае если хотя бы одно условие является верным (true), то код внутри условия будет выполнен:
```python 
a = 1.1
if a != 1.1 or a > 0:
   print ("Проверка сработала")
```
Операции на условие:
```python
num = input ("Введите число: ")

if int (num) > 0:
	if int (num) > 10:
		print ("Вы ввели число больше 10")
		if int (num) >= 50:
			print ("Вы ввели число больше 50")
	else:
		print ("Вы ввели число меньше 10 и больше 0")
elif int (num) < -10:
	print ("Вы ввели число меньше -10")
else:
	print ("Вы ввели число меньше 0 и больше -10")
print ("All is okay!")

name = input ()
A = 'Yes' if name != "Test" else 'No'
print (A)
```
#### 6 Циклы и операторы)  ####
Циклы позволяют выполнять некий код несколько раз подряд. Это особенно полезно при работе с массивами. В языке Python циклы немного отличаются по своему виду от циклов в других языках. К примеру, во многих языках есть цикл do..while, который выполняется один раз сто процентов, а потом проверяет условие. В питоне его нет- но можно заменить.

Также важно отметить, что вы можете создать бесконечный цикл, но с оператором break, который выйдет из цикла:
```python
a = 10
while True:
  a -= 1
  if a == 0:
    break
```

Такой цикл сработает корректно, так как у нас есть оператор break, который сработает в нужный момент и выйдет из цикла.
Пример кода с циклами
```python
i = 1000
while i > 100:
	print (i)
	i /= 2

for j in 'hello world':
	if j == 'w':
		break
else:
	print ("Буквы а нету в слове")
```
#### 7 Списки ####
Списки можно также назвать массивами, так как выполняют они схожую роль. В Python существует множество разновидностей таких "массивов". В уроке мы рассмотрели лишь первый тип, который называется списком и имеет следующие характеристики:
его элементы можно переопределять;
в него можно добавлять новые элементы;
из него можно удалять элементы;
в качестве ключей идут индексы (числа - 0, 1, 2...).
Это не все характеристики списка, тем не менее это ключевые моменты, которые отличают его от других "массивов" в языке Python.

Для списков существует большое количество функций, которые можно применять для добавления, удаления или же поиска элементов.

Пример создания списка:

```python
lis = ["Андрей", "Иван", "Василий", "Петро", "Максим", "Дима"]
```
```python
l = []
lis = [1, 56, 'x', 34, 2.34, ['S', 't', 'r', 'o', 'k', 'a']]
print (lis)

a = [a + b for a in 'list' if a != 's' for b in 'soup' if b != 'u']
print (a)

l.append (23)
l.append (34)
b = [24, 67]
l.extend (b) # все элемены b расширяют l
#i>>> print (l)
#[23, 34, 24, 67]
l.insert (1, 56)
l.append (34)
l.remove (34)
l.pop (0)
print (l.index (56))
print (l.count (34))
l.sort ()
l.reverse ()
l.clear ()

print (l)
```

#### 8 Индексы и срезы ####
Нумерация в списках начинается с нуля, так как список по большей части своей это просто массив, то как в обычном массиве отсчет ведется от 0. Поэтому первый элемент по индексу будет 0, второй - 1, третий - 2 и так далее. Если мы попытаемся взять несуществующий элемент, то это приведет к ошибке.
```python
a = [0, 23, "Hi"] # Список
print (a[4]) # Выдаст ошибку, так как элемента не существует
```
Очень удобной функцией языка Python является возможность брать элементы с конца при помощи отрицательных индексов. К примеру, если нам нужен второй элемнет с конца, то мы можем записать это так:
```python
a = [0, 23, "Hi", 1.56, 9] # Список
print (a[-2]) # Будет выведено 1.56
```
Срезы
Срезы позволяют обрезать список, взяв лишь те элементы, которые нам будут нужны. Они работают по следующей схеме: list[НАЧАЛО:КОНЕЦ:ШАГ].
Начало - с какого элемента стоит начать (по умолчанию равна 0);
Конец - по какой элемент мы берем элементы (по умолчанию равно длине списка);
Шаг - с каким шагом берем элементы, к примеру каждый 2 или 3 (по умолчанию каждый 1).
Один, несколько или даже все параметры могут быть пропущены.
```python
list[::3] # Берем каждый третий элемент
list[2::2] # Начиная со второго элемента берем каждый второй элемент
list[4:6:] # Начиная с 4 элемента берем все элементы по 6 элемент
list[::] # Берем все элементы
```
Также могут быть использованы отрицательные числа для срезов.
```python
l = [34, 'sd', 56, 34.34]

i = 0
while i < 4:
	print (l[i])
	i += 1
	
print (l[-2::-2])
```

#### 9 Кортежи tuple ####
Кортежи это по сути те же самые списки, только с несколькими отличиями. Кортежи нельзя изменять после их создания, а также они весят чуть меньше, чем списки.

При работе с кортежами действуют абсолютно все методы, о которых было рассказано в уроке про списки. Единственные методы, которые не будут работать, так это методы изменяющие кортеж: удаление, добавление элементов, сложение кортежей и тому подобные.

Кортежи можно создать двумя способами:
при помощи ключевого слова a = tuple ('hello');#разбиваем слово на список
при помощи литерала a = ('a','b').
Их главное преимущество в том, что их нельзя изменять, поэтому ни вы, ни кто-либо другой не сможет как случайно, так и намерено изменить кортеж.

#### 10 Словари dict ####
Словари отличаются способом записи их, а также индексами. Если в обычном списке в качестве индексов выступают числа (0, 1, 2...), то здесь на их замену приходят "ключи". Так, мы можем создать некий ключ (Студент Федя, например) и добавить к нему целый ряд характеристик (список) в качестве одного элемента. Теперь найти нужного нам студента будет намного проще, так как мы просто будет оперировать ключами, а не числами.

Во многих других языках программирования такие словари зачастую называются ассоциативными массивами, поэтому не редко можно услышать и такое название.

Чтобы создать словарь вы можете воспользоваться следующей конструкцией:
```python
d0= {'test' : 1, 'prod': 2}
d1= dict (short = 'dict', longer = 'dictionary')
d2= dict ([(23,34),(56,87)])
d3= dict.fromkeys(['a','b'], 3)
```
Методы словарей:
```python
dict.clear() # очистка словаря
dict.copy() # возвращает копию словаря
dict.fromkeys(seq[,value]) # создает словарь с ключами из seq и значениям value
dict.get(key[,default]) # возвращает значение ключа, если ключа нет - возвращаем default
dict.items() # возвращает пары ключ - значени
dict.keys() # вернуть ключи
dict.pop(key,[,default]) # удаляет ключ и возвращает значение. Если ключа нет, возвращает default (вместо исключения по умолчанию)
dict.popitem() # удаляет и возвращает пару (ключ - значение)
dict.setdefault(key[,default])  - возвращает значение ключаб если его нет - создает ключ с default
dict.update([other]) # обновляет словарь, добавляя пары из other. Существующие ключи перезаписываются. Возвращает None.
dict.values() #  возвращает значения в словаре
```

Применение словарей в Python:
```python
d = {a : a ** 2 for a in range(7)}
print (d)

person = {'name' : {'last_name': 'Иванов', 'first_name': 'Иван', 'middle_name': 'Иванович'}, 'address': ['г. Андрюшки', 'ул. Васильковская д. 23б', 'кв.12'], 'phone': {'home_phone': '34-67-12', 'mobile_phone': '8-564-345-23-65', 'mobile_phone_2': 'Нет'}}
# print (person['phone']['mobile_phone'])

print (person.keys ())
```
#### 11 Множества set  ####
Множества также схожи с массивами, но есть несколько отличий. Во-первых, множества создаются в абсолютно случайном порядке каждый раз. Вы можете разместить элементы как вам будет угодно, но они все равно будут расположены впоследствии в случайном порядке. Во-вторых, множества не могут иметь повторяющихся элементов, поэтому все элементы, которые будут одинаковыми не будут выведены повторно.

Их очень удобно использовать, если вы хотите удалить повторяющиеся элементы из списка, например:
```some_list = [12, 56, 91, 12]
set(some_list) # Результат: 12, 56, 91
```
Также для существует огромное множество операций, которые приведены ниже:
```
len(s) - число элементов в множестве (размер множества).
x in s - принадлежит ли x множеству s.
set.isdisjoint(other) - истина, если set и other не имеют общих элементов.
set == other - все элементы set принадлежат other, все элементы other принадлежат set.
set.issubset(other) или set <= other - все элементы set принадлежат other.
set.issuperset(other) или set >= other - аналогично.
set.union(other, ...) или set | other | ... - объединение нескольких множеств.
set.intersection(other, ...) или set & other & ... - пересечение.
set.difference(other, ...) или set - other - ... - множество из всех элементов set, не принадлежащие ни одному из other.
set.symmetric_difference(other); set ^ other - множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих.
set.copy() - копия множества.
```

С множествами можно выполнять множество операций: находить объединение, пересечение...

#### 12 Функции ####

Функции можно назвать небольшими подпрограммами, куда можно вынести повторяющийся код и обращаться к нему, когда это будет нужно. Функции значительно облегчают построение программ, так как нам не надо копировать однотипный код множество раз, а можно просто воспользоваться одной общей функцией.

В Python функции создаются при помощи ключевого слова def. Каждая функция может иметь какие-либо параметры или же не иметь их вовсе. Также функции способны что-либо возвращать в ходе выполнения кода в них или же ничего не возвращать.

```python
def some_test(): # Функция без параметров
    x = 23
    return x # Функция возвращает что-либо

def some_test_2(a, b, c): # Функция с 3 параметрами
    return a * b * c # Функция возвращает результат умножение чисел

def print_something(word, prefix): # Функция с 2 параметрами
    print (prefix, "-", word)
    pass # Функция ничего не возвращает
```
Когда функция ничего не возвращает, то необходимо прописывать ключевое слово pass. Также функции могут возвращать другие функции, тем самым вызывая их. Чтобы обратиться к функции необходимо прописать её названи и передать параметры, если таковы имеются

```python
res = some_test_2 (2, 67, 12)
```
Здесь мы все записываем в переменную res, так как функция вернет результат, который мы можем куда-то поместить.
Если функция не должна выполнять большой объем кода, то можно воспользоваться анонимной функцией. Для этого нам потребуется функция lambda. Пример создания такой функции:
```python
multiple = lambda a, b: a * b
multiple(7, 12)
```
Такая функция не имеет названия, но её можно присвоить к переменной, которую в дальнейшем необходимо вызывать как обычную функцию.
Примеры функций

```python
def func (**args):
	return args

print (func (short='dict', longer='dictionary'))

add = lambda x, y: x * y
print (add (2, 5))
print (add ('q', 5))

print ((lambda x, y: x * y)(2, 6))

fun = lambda *args: args
print (fun (2, 56, 78.56))
```
# ЗАДАНИЯ
```python
#Ваша задача сделать функцию, которая будет принимать 2 параметра (время и скорость) и возвращать сколько проедет километров человек исходя из параметров. Теперь вам необходимо вывести это на экран. Если человек проехал 1 километр, то писать так: "Вы проедете: 1 километр", иначе писать так: "Вы проедете: {здесь цифра} километров". Последнее выполнить через lambda

def count_distance (v, t):
    print ("скорость = ", v)
    print ("время = ", t)
    return v*t

s = count_distance(1,1);
back_mess = (lambda a: "kilometr" if a == 1 else "kilometrov")(s)
print ("Вы проедете: ", s, back_mess )

# Создайте функцию, которая будет принимать параметр и внутри этой функции будет еще одна функция, которая также будет принимать параметр. Вторая функция должна просто суммировать оба параметра, а первая должна вернуть результат.

def funk1(par1):
    def funk2(par2):
        return par1 + par2
    return funk2

summa_sotka_funk = funk1(100)
res = summa_sotka_funk(200)
print ("res = ", res)

#Создайте функцию с параметрами по умолчанию. Вызовите эту функцию и передайте в нее не все параметры. Функция должна вернуть деление всех чисел. При этом добавьте проверку при деления на ноль.

def chastnoe (a,b,c = 1):
    if ((a == 0) or (b == 0) or (c == 0 )):
        print ("alarm")
    else:
        return int(a/b/c)

diff = chastnoe (8,4)
print ("diff=", diff)

#Создайте функцию, которая может принимать не установленное количество параметров. Выведите сумму всех переданных параметров.
def many_params (*params):
    res_sum = 0
    for i in params:
        print ("i=",i)
        res_sum += i
    return res_sum

list = (3,6)
print (many_params(3,5))

#Создайте анонимную функцию с неустановленным количеством параметров. Функция должна выводить все параметры на экран.
anon_funk = lambda *args: print (args)
anon_funk(3,7)
```
#### 13 Исключения ####
Исключения это то, что может непредвиденно возникнуть в ходе работы программы. Если такое случится, то программа просто завершит свою работу. Чтобы такого не допустить вам всегда стоит добавлять исключения. К примеру, вы хотите добавить возможность деления двух чисел? Добавьте также исключение, которое позволит проверять, не является ли делитель нулем. Или же вы хотите что-то вписать файл, но для начала его необходимо открыть. Пропишите исключение, которое будет срабатывать если файл не найден, чтобы программа не пыталась его открывать повторно.
Конструкция самих исключений очень проста. Вам необходимо сначала что-то попробовать сделать, а потом поискать ошибку, если она будет найдена, то выведется ваш код, иначе все сработает корректно и никаких ошибок не будет.

```python
try:
    print("Hello")
except ArithmeticError:
    print("Something went wrong")
else:
    print("Nothing went wrong")
finally:
    print ("end of work")
```
```
      +-- StandardError
      |    +-- BufferError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |         +-- UnicodeError
      |              +-- UnicodeDecodeError
      |              +-- UnicodeEncodeError
      |              +-- UnicodeTranslateError
```

#ЗАДАНИЯ:
```python
#example:
try:
    print("Hello")
except:
    print("Something went wrong")
else:
    print("Nothing went wrong")
finally:
    print ("end of work")

#Попросите пользователя ввести возраст, если он ввел не возраст, то скажите ему об этом и попросите сделать это еще раз. Сделайте это в цикле, чтобы каждый раз спрашивался возраст, пока пользователь его наконец не введет

age_int = None
while (age_int == None):
    try:
        age = input("insert age\n")
        age_int = int(age)
    except:
        print ("age is not ok")
    else:
        print ("ok")

#Создайте исключение, которое сработает при использовании несуществующей переменной. К примеру, вы хотите присвоить значение несуществующей переменной к другой переменной. Такое исключение носит название NameError.

try :
    #exist = unexist + 1
    res = 3/1
except NameError:
    print ("smth bad")
except ZeroDivisionError:
    print ("zero div")
else:
    print ("ok")
#Допустим вы хотите вызвать функцию, но не знаете существует ли она. Создайте исключение, которое будет выдавать ошибку, если функции не существует.
try:
    bad_func(3)
except NameError:
    print ("bad f")
```
#### 14 файлы ####
Перед началом работы с любым текстовым документом важно изначально открыть сам документ. При этом, если его не будет, то это вызовет ошибку.
По этой причине, всегда стоит оформлять открытие документов при помощи исключений или же при помощи метода with..as, который будет изучен в следующем уроке.

Для открытия файла существует функция open, которая открывает файл разными способами. Вот все возможные типы открытия файла:
```
'r' открытие на чтение (является значением по умолчанию).
'w' открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
'x' открытие на запись, если файла не существует, иначе исключение.
'a' открытие на дозапись, информация добавляется в конец файла.
'b' открытие в двоичном режиме.
't' открытие в текстовом режиме (является значением по умолчанию).
'+' открытие на чтение и запись
```
Для записи текста в файл существует метод write, а для чтения метод read. После того, как с файлом была закончена работа его обязательно необходимо закрыть. Это делается при помощи метода close. Рекомендую сразу же при открытии файла его закрывать, чтобы в дальнейшем не забыть это сделать. При этом всю работу с файлом осуществлять между его открытием и закрытием.

```python
f = open ('text.txt', 'w')
f.write ('Hi, it's me!
Test')
f.close ()
# for line in f:
#   print (line)
```
#ЗАДАНИЯ:
```python
#!/usr/bin/env python3
#Создайте файл hi.txt и поместите туда строку "Какая-угодно информация!" и закройте файл.
#Откройте файл только для чтения и выведите информацию на экран.
f = open('file.txt', 'w+') # если r+ то файл не создастся
f.write('Какая-угодно информация3!')
f.seek(0)
a = f.read();
print ("a=", a)

#Постарайтесь открыть файл, которой вы не создавали. Создайте исключение, которое сработает при не нахождении такого файла. Такое исключение называется FileNotFoundError.
try:
    f=open("unexist_file", 'r')
except FileNotFoundError:
    print ("second error")
except: #default exept must be last or error
    print ("error with file open")

#Создайте файл "example.txt" и впишите туда текст "Привет" после чего закройте его. Теперь постарайтесь открыть этот же файл при помощи команды "x", которая открывает файл для чтения, если такого нет. Вам будет выдана ошибка, которую вы должны обработать в исключении. Ошибка будет называться FileExistsError. В finally пропишите закрытие файла, а в except пропишите верное открытие файла при помощи 'a'
file_name = "example.txt";
f = open (file_name, 'w')
f.write('some info')

try:
    f = open (file_name, 'x')
except FileExistsError:
    print ("error was excepted")
    f = open (file_name, 'a')
finally:
   f.close ()
```
